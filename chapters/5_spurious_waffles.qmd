# Ch 5. The Many Variables & The Spurious Waffles {#mcelreath_ch5}


Load the [Waffle House](https://www.snopes.com/fact-check/fema-waffle-house-index/) data.

```{r, message = F, warning = F}
library(rethinking)
library(pacman)
data(WaffleDivorce)
d <- WaffleDivorce

p_load(daggity, install=FALSE)
```


```{r, message = F, warning = F}
rm(WaffleDivorce)

#detach(package:rethinking, unload = T)
library(brms)
library(tidyverse)
library(dplyr)
```


> Reasons given for multiple regression models include: (1) Statistical -control” for confounds

DR: but endogenous controls can make this problem worse

## 5.1. Spurious association {-}

> But there’s no reason high marriage rate must cause more divorce

DR: what would this even mean? ... the 'causal' part is ambiguous in this example, particularly when we are talking about aggregates like 'rates for the whole population'. I'm familiar with the framework of the Rubin Causal model, where we consider the counterfactual state of some real-world outcome, when another real-world outcome would be set at one level or another. 

> easy to imagine high marriage rate indicating high cultural valuation of marriage and therefore being associated with low divorce rate

DR: but the latter is not causal

> Since the outcome and the predictor are both standardized, the intercept - should end up very close to zero 

$\alpha ∼ Normal(0, 0.2)$

DR: why not exactly 0? Is this a 'sample drawn from the population' issue?


> So when $\beta_A = 1$, a change of 1.2 years in median age at marriage is associated with a full standard deviation change in the outcome variable  [which he thinks is absurdly large]


DR: But why are these 'absurdly large', maybe the sd in the outcome is small too?

> [a model] that includes both age at marriage and marriage rate will help us. 

DR: maybe but these are aggregates. Casual thinking will be difficult.  Primitives are more like 'whether an individual of a.certain age gets married or divorced'

> causal impact

DR: redundant language. All impacts are causal :)

> DAG will tell you the consequences of intervening to change a variable. But only if the DAG is correct

> Perhaps a direct effect would arise because younger people change faster than older people and are therefore more likely to grow incompatible with a partner. Second, it has an indirect effect by influencing the marriage rate, which then influences divorce, A $\rightarrow$  M $\rightarrow$  D

> these different arrows, we need more than one statistical model.

> Model m5.1, the regression of D on A, tells us only that the total influence of age at marriage is strongly negative with divorce rate

DR: May not be *influence*... because unobserved factor could drive both

> The 'total' here means we have to account for every path from A to D. There are two such paths in this graph: $A \rightarrow  D$, a direct path, and $A \rightarrow  M \rightarrow D$, an indirect path. In general, it is possible that a variable like A has no direct effect at all on an outcome like D. It could still be associated with D entirely through the indirect path. That type of relationship is known as mediation, and we'll have another example later.


> This DAG is also consistent with the posterior distributions of models m5.1 and m5.2. Why? Because both M and D 'listen' to A

> conditional independencies  ... which variables become dis-associated when we condition on some other set of variables. D

... that every pair of variables is correlated. This is because there is a causal arrow between every pair. These arrows create correlations.

> DR: but effects could add up to zero by coincidence. (Actually, he has a case like this further down, he just fails to mention it here)

> They share a cause, and this leads them to be correlated with one another through that cause. But suppose we condition on A. All of the information in M that is relevant to predicting D is in A. So once we've conditioned on A, M tells us nothing more about D. So in the second DAG, a testable implication is that D is independent of M, conditional on A. In other words, $D \perp  M|A$.

> Here’s the code to define the second DAG and display the implied conditional independencies.

```{r}
library(dagitty)

DMA_dag2 <- dagitty::dagitty('dag{ D <- A -> M }')
impliedConditionalIndependencies( DMA_dag2 )

```

> So for example once you fit a multiple regression to predict divorce using both marriage rate and age at marriage, the model addresses the questions: (1) After I already know marriage rate, what additional value is there in also knowing age at marriage? (2) After I already know age at marriage, what additional value is there in also knowing marriage rate?

DR: can we differentiate 1 from 2?

### Coding data vis and univariate models  (Kurz) {-}

Kurz on themes and plots:^[ Going forward, each chapter will have its own plot theme. In this chapter, we’ll characterize the plots with `theme_bw() + theme(panel.grid = element_rect())` and coloring based off of "firebrick".]

```{r}
# install.packages("ggrepel", dependencies = T)
library(ggrepel)

d %>%
  ggplot(aes(x = WaffleHouses/Population, y = Divorce)) + #note we can put transformations *within* the `aes`
  stat_smooth(method = "lm", fullrange = T, size = 1/2,
              color = "firebrick4", fill = "firebrick", alpha = 1/5) + #the linear plot and the shaded 'some sort of bounds' thing
  geom_point(size = 1.5, color = "firebrick4", alpha = 1/2) +
  geom_text_repel(data = d %>% filter(Loc %in% c("ME", "OK", "AR", "AL", "GA", "SC", "NJ")),  
                  aes(label = Loc), 
                  size = 3, seed = 1042) +  # this makes it reproducible
  scale_x_continuous("Waffle Houses per million", limits = c(0, 55)) +
  ylab("Divorce rate") +
  coord_cartesian(xlim = c(0, 50), ylim = c(5, 15)) +
  theme_bw() +
  theme(panel.grid = element_blank())  #removes gridlines
```
*Note: I'm skipping the map plotting, for now, even though it's a cool vis.*

```{r}
#| label: standardize_mam
#| code-summary: "Standardize median age marriage"

d <-
  d %>%
  mutate(MedianAgeMarriage_s = (MedianAgeMarriage - mean(MedianAgeMarriage)) /
           sd(MedianAgeMarriage))
 
```


```{r}
#| code-summary: "fit the first univariable model."

b5.1 <- 
  brm(data = d, 
      family = gaussian,
      Divorce ~ 1 + MedianAgeMarriage_s,
      prior = c(prior(normal(10, 10), class = Intercept),
                prior(normal(0, 1), class = b),
                prior(uniform(0, 10), class = sigma)),
      iter = 2000, warmup = 500, chains = 4, cores = 4,
      seed = 5,
      file = "fits/b05.01")

```

```{r}
print(b5.1)

```

Below...

- Create: `nd` -- tibble of standardized predictor values to plot over
- apply `fitted` to `nd` with the `newdata` argument to fit values over this range (rather than over the  data the model was fit on)

"to return model-implied expected values for `Divorce`"

```{r, fig.width = 3, fig.height = 3}
# define the range of `MedianAgeMarriage_s` values we'd like to feed into `fitted()`
nd <- tibble(MedianAgeMarriage_s = seq(from = -3, to = 3.5, length.out = 30))

# now use `fitted()` to get the model-implied trajectories
f <- 
  fitted(b5.1, newdata = nd) %>%
  as_tibble() %>%
  # tack the `nd` data onto the `fitted()` results
  bind_cols(nd)

```


And plot this... 

```{r, fig.width = 3, fig.height = 3}
# plot
ggplot(data = f, 
       aes(x = MedianAgeMarriage_s, y = Estimate)) +
  geom_smooth(aes(ymin = Q2.5, ymax = Q97.5),
              stat = "identity",
              fill = "firebrick", color = "firebrick4", alpha = 1/5, size = 1/4) +
  geom_point(data = d, #overlaying the original data
             aes(y = Divorce), 
             size = 2, color = "firebrick4") +
  ylab("Divorce") +
  coord_cartesian(xlim = range(d$MedianAgeMarriage_s), 
                  ylim = range(d$Divorce)) +
  theme_bw() +
  theme(panel.grid = element_blank())                   
```

Next   ... they do the same thing but with marriage rate as the predictor
```{r}
d <-
  d %>%
  mutate(Marriage_s = (Marriage - mean(Marriage)) / sd(Marriage))
```

```{r}
b5.2 <- 
  brm(data = d, 
      family = gaussian,
      Divorce ~ 1 + Marriage_s,
      prior = c(prior(normal(10, 10), class = Intercept),
                prior(normal(0, 1), class = b),
                prior(uniform(0, 10), class = sigma)),
      iter = 2000, warmup = 500, chains = 4, cores = 4,
      seed = 5,
      file = "fits/b05.02")


```

```{r}
print(b5.2)

```


I'll skip plotting this for now

### Multiple regression notation {-}

Model with

`mu <- a + bM*M + bA*A`

> Notice how bA doesn’t move, only grows a bit more uncertain, while bM is only associated with divorce when age at marriage is missing from the model. You can interpret these distributions as saying:

> Once we know median age at marriage for a State, there is little or no additional predictive power in also knowing the rate of marriage in that State.
> In that weird notation, $D \perp M|A$. This tests the implication of the second DAG from earlier.

> Since the first DAG did not imply this result, it is out

DR: This seems like a very weak test and a poor strategy for making inferences about causality (more so *running* with those inferences to underly future modeling).  Even when age *is* present in the model, the compatibility intervals for the marriage rate coefficient include rather large coefficients in either direction.


### Fitting the (multivariate) model {-}

'Priors for each slope'^["Notice we’re using the same prior prior(normal(0, 1), class = b) for both predictors. Within the brms framework, they are both of class = b. But if we wanted their priors to differ, we’d make two prior() statements and differentiate them with the coef argument."]

```{r}
b5.3 <- 
  brm(data = d, 
      family = gaussian,
      Divorce ~ 1 + Marriage_s + MedianAgeMarriage_s,
      prior = c(prior(normal(10, 10), class = Intercept),
                prior(normal(0, 1), class = b),
                prior(uniform(0, 10), class = sigma)),
      iter = 2000, warmup = 500, chains = 4, cores = 4,
      seed = 5,
      file = "fits/b05.03")
```


```{r}
print(b5.3)
```

 `mcmc_plot(b5.3)` seems to produce a ggplot object:

```{r}

(
xxx <- mcmc_plot(b5.3) + ggtitle("My fancy bayesplot-based coefficient plot") +
  theme_bw() +
  theme(axis.text.y = element_text(hjust = 0),
        axis.ticks.y = element_blank(),
        panel.grid = element_blank()
  )
)



```
With the `bayesplot::mcmc_intervals` function you can specify what you want more precisely. 

```{r}
# install.packages("bayesplot", dependencies = T)
library(bayesplot)

post <- posterior_samples(b5.3)

color_scheme_set("red")
mcmc_intervals(post[, 1:4], 
               prob = .7,
  prob_outer = 0.99,
               point_est = "mean") + #Kurz and the default use 'median'
  ggtitle("My fancy bayesplot-based coefficient plot") +
  theme_bw() +
  theme(axis.text.y = element_text(hjust = 0),
        axis.ticks.y = element_blank(),
        panel.grid = element_blank())
```

Note; this approach it required you to work with the `posterior_samples()` instead of the brmsfit object. Just to be different, I set `point_est = "mean"` instead of median, and `prob = .7` for the 'inner interval' and `prob_outer = 0.99`.

> The tidybaes::stat_pointinterval() function offers a third way, this time with a more ground-up ggplot2 workflow.

... I will return to that later, perhaps


### Plotting multivariate posteriors. {-}

> (1)  Predictor residual plots. These plots show the outcome against residual predictor
values. ...
> (2) Posterior prediction plots. These show model-based predictions against raw data,
or otherwise display the error in prediction. They are tools for checking fit and
assessing predictions. ...
> (3) Counterfactual plots. These show the impliTd predictions for imaginary experiments. These plots allow you to explore the causal implications of manipulating one or more variables.



#### Predictor residual plots {-}

> To get ready to make our residual plots, we'll predict `Marriage_s` with `MedianAgeMarriage_s`.

DR: going for 'the surpriseing part of one explanatory variable once you already know another'. Somehow I find it strange that we're doing a Bayesian estimate to get this object too, rather than just doing a simple least-squares linear fit. In the context of the latter I recall some clean 'regression algebra' results such as the 'long and short regression' and 'omitted variable bias' formulae.

```{r b5.4}
b5.4 <- 
  brm(data = d,
      family = gaussian,
      Marriage_s ~ 1 + MedianAgeMarriage_s,
      prior = c(prior(normal(0, 10), class = Intercept),
                prior(normal(0, 1), class = b),
                prior(uniform(0, 10), class = sigma)),
      iter = 2000, warmup = 500, chains = 4, cores = 4,
      seed = 5,
      file = "fits/b05.04")
```

```{r}
print(b5.4)
```

> With `fitted()`, we compute the expected values for each state (with the exception of Nevada). Since the `MedianAgeMarriage_s` values for each state are in the date we used to fit the model, we'll omit the `newdata` argument.

```{r}
f <- 
  fitted(b5.4) %>%
  as_tibble() %>%
  bind_cols(d)

head(f)
```

After a little data processing, we can make Figure 5.3.

```{r, fig.width = 3, fig.height = 3}
f %>% 
  ggplot(aes(x = MedianAgeMarriage_s, y = Marriage_s)) +
  geom_point(size = 2, shape = 1, color = "firebrick4") +
  geom_segment(aes(xend = MedianAgeMarriage_s, yend = Estimate), 
               size = 1/4) +
  geom_line(aes(y = Estimate), 
            color = "firebrick4") +
  coord_cartesian(ylim = range(d$Marriage_s)) +
  theme_bw() +
  theme(panel.grid = element_blank())     
```



**Skipped a bunch here; come back to it**

> The trick with simulating counterfactuals is to realize that when we manipulate some variable X, we break the causal influence of other variables on X.

> Now we can use `sim`, which you met in the previous chapter, to simulate observations from model `m5.3_A`. But this time we’ll tell it to simulate both M and D, in that order. Why in that order? Because we have to simulate the influence of A on M before we simulate the joint influence of A and M on D. The vars argument to sim tells it both which observables to simulate and in which order.



```{r, eval=FALSE}
# prep data 5.21
sim_dat <- data.frame( A=A_seq )
# simulate M and then D, using A_seq
s <- sim( m5.3_A , data=sim_dat , vars=c("M","D") )
```
```{r, eval = FALSE}
plot( sim_dat$A , colMeans(s$D) , ylim=c(-2,2) , type="l" ,
xlab="manipulated A" , ylab="counterfactual D" )
shade( apply(s$D,2,PI) , sim_dat$A )
mtext( "Total counterfactual effect of A on D" )
```
