{
  "hash": "60bed3576bbc26a137adaec7b264ff43",
  "result": {
    "markdown": "# Power analysis discussion and workflow (Elsey) {#power-workflow}\n\n[^power_analysis_framework_2-1]\n\n[^power_analysis_framework_2-1]: By Jamie Elsey, incorporating some comments and suggestions from David Reinstein.\n\n\n\n## Discussion and framework\n\n### Introduction and goals\n\nThe purpose of this document is to propose the fundamentals for a workflow for power analyses. I will begin with a standard frequentist analysis.[^power_analysis_framework_2-2]\n\n[^power_analysis_framework_2-2]:  Although this started from a Bayesian paradigm, the overarching framework is applicable to any analytic approach. Starting frequentist will make the code easier to run as well. Note that as Bayesian power analyses can be very time consuming (at the moment/with our current setup), in some cases even if you ultimately might perform a Bayesian analysis, it may make some sense to run frequentist approaches first. In many cases the estimates from Bayesian and frequentist approaches will tend to converge. I (Jamie) suspect general estimates from frequentist approaches would be quite similar to those of Bayesian approaches, if the goal of the analysis (what you want to make an inference about) is the same. I will make an accompanying document with an example of a Bayesian power analysis that should be computationally feasible to accompany this.\n\nThe general approach laid out here can be the basis for developing and build a library of common analyses and inference goals.\n\n::: {.callout-note collapse=\"true\"}\n## Helpful future additions to the toolkit would include\n\n-   clear and flexible ways to generate hypothetical data sets, and\n\n-   adding further analytic designs.\n\nDR: I think tools like DeclareDesign can help with this.\n:::\n\nThis is not intended as an exhaustive introduction to the fundamentals of statistical power--I assume you are reasonably well-versed in some general principles of statistical inference and hypothesis testing, as well as in the basic idea of what power analysis is.[^power_analysis_framework_2-3]\n\n[^power_analysis_framework_2-3]: DR: We can cover this in the earlier section, or link relevant explanations.\n\nWe will focus solely on 'simulation-based' power analysis,[^power_analysis_framework_2-4] and not on ways of mathematically (analytically) deriving power.\n\n[^power_analysis_framework_2-4]: Essentially, we draw many hypothetical versions of a data set with certain properties under certain conditions, compute our estimates and tests, and tally 'how often' it yields certain results.\n\n### Definition of power\n\nIn frequentist null hypothesis significance testing (NHST), power is typically defined as 'the probability that we can reject the null hypothesis, if the alternative hypothesis is indeed true' (i.e., power is the 'true positive rate'). More precisely, we may express this as 'power against a *particular* alternative hypothesis'.[^power_analysis_framework_2-5]\n\n[^power_analysis_framework_2-5]: DR: may be worth putting maths here at some point, and also give a canonical reference.\n\n::: {.callout-note collapse=\"true\"}\n## From wikipedia: The statistical power of a binary hypothesis test...\n\nThe statistical power of a binary hypothesis test is the probability that the test correctly rejects the null hypothesis $H_0$ when a specific alternative hypothesis $H_{1}$ is true. It is commonly denoted by $1-\\beta$, and represents the chances of a \"true positive\" detection conditional on the actual existence of an effect to detect. ... as the power of a test increases, the probability $\\beta$ of making a type II error by wrongly failing to reject the null hypothesis decreases.\n\n[link accessed 12 Apr 2022](https://en.wikipedia.org/wiki/Power_of_a_test)\n:::\n\nNote that some Bayesian statisticians question the validity and usefulness of this presentation of power analysis.[^power_analysis_framework_2-6]\n\n[^power_analysis_framework_2-6]: This engages deep issues in the conception of probability. From the frequentist perspective you imagine a fixed underlying true parameter and consider the many data sets that might hypothetically arise from it - 'the true parameter is fixed and the data varies'. In Bayesian reasoning you note that you have 'uncertainty about the underlying parameter' but you  'consider the data as fixed'. A Bayesian approach does not tend to  consider 'the probability that the data arises in a particular way under a null hypothesis'; however 'Bayesian hypothesis testing' is discussed in the literature. (Presumably, it envisions 'rejecting a hypothesis' where the posterior probability that the hypothesis holds is sufficiently small).\n\n    \\\n\nBefore we conduct an experiment (or run a survey, or collect data for an analysis), there are many hypothetical future data sets we might observe. Whether we favor a frequentist or Bayesian approach, it seems reasonable to ask: *'Given the range of data that I might observe, how likely is it that I can make certain conclusions?'*. [^power_analysis_framework_2-7]\n\n[^power_analysis_framework_2-7]: The conclusion or inference one wishes to make from a data set can go far beyond simply saying something like \"there is a non-zero difference between groups\" (although this is probably the most common inference people first consider). Or a comparable statement posed in probabilistic terms...\n\n    Frequentist: 'if there had been a zero difference between these groups (H0), this data is unlikely to have been generated'.\n\n    Bayesian: 'the posterior distribution puts most of the probability mass on there being a difference between groups greater than (some moderate amount).'\n\nWe can broaden the idea of power to indicate the probability that our proposed sample yields information that allows us to make some specific kind of inference about the data-generating process.  Given a particular underlying effect (or range of effects, or lack thereof), and a particular sample size (or range of sample sizes), we may ask 'what is the probability of'... ?:[^power_analysis_framework_2-8]\n\n[^power_analysis_framework_2-8]: Note that these could all be either Bayesian or frequentist, depending on how you specify your goals/inferences.\n\n-   'determining' that there is a non-zero difference between two conditions,[^power_analysis_framework_2-9]\n-   detecting some 'smallest effect size of interest',\n-   a 'false positive',[^power_analysis_framework_2-10]\n-   achieving a desired level of precision around a particular parameter estimate, or\n-   finding an effect 'likely equivalent to zero' or 'unlikely to be far from zero'.[^power_analysis_framework_2-11]\n\n[^power_analysis_framework_2-9]: 'Determining' is in scare quotes; ultimately, we are making probabilistic statements about...\n\n    -   the 'true effect size' ('we make the decision that, most probably, there is a non-zero difference') or\n\n    -   about the likelihood of observing data like this under some conditions (frequentist: 'this data would be very unlikely if there were a zero effect').\n\n    \\\n\n[^power_analysis_framework_2-10]: I.e., the probability of concluding that there is a difference between groups when in fact there is no difference (the standard 'Type 1 error', aka the 'size' of a test).\n\n[^power_analysis_framework_2-11]: This is sometimes called 'equivalence testing'. In Bayesian estimation, you can consider a 'range of practical equivalence' (ROPE). Here, if a large enough proportion of the posterior (of the difference between two groups, say) falls in this range, you conclude that 'to all intents and purposes these groups are equivalent.'\n\n    \\\n    \n::: {.callout-note collapse=\"true\"}\n## 'Power of an equivalence test' (key aside)\n\nWe may wish to estimate the 'likelihood that we will determine that the effect is in a near-zero range', when the true effect size are in fact zero or very small. The former determination is called an 'equivalence test'; thus we may want to compute the 'power of an equivalence test against a particular distribution of true (small) effect sizes'. I'll call the latter the 'equivalence distribution' for now.\n\n1. Determine *how* we wish to compute our equivalence test (there may be dragons here)\n2. Simulate a large number of data sets arising under the equivalence distribution \n3. Compute the equivalence test for each simulated data set. \n4. Count the share of these that 'determine the effect is near zero'. This share is the 'power of our equivalence test against the equivalence distribution'\n\n::: \n\nHence, a power analysis helps frame our prospective research project in relation to the goals we would like to achieve.[^power_analysis_framework_2-12] It provides uswith an estimate (and it is indeed an estimate, not a certainty!) of the probability that we will be able to make the inference we wish to make, given various factors both inside and outside of our control. (See discussion in fold.)\n\n[^power_analysis_framework_2-12]: See the 'diagnosands' of the `declaredesign` framework.\n\n::: {.callout-note collapse=\"true\"}\n## What is 'in our control'?\n\nWe might think of sample size as *in* our control, which it generally is, but this is typically limited by practical considerations outside of our control (such as the availability of a sample or financial constraints). Conversely, effect size is often considered *out* of our control ; however we can sometimes increase the 'dosage' we give, or try to select a particular group of participants who might be particularly susceptible to our effect of interest.\n:::\n\n### General workflow for simulation-based power analysis\n\n*Simulation-based power analysis proceeds in four primary steps:*\n\n1.  **Generate** a large number of '**simulated data sets**' for the analysis.[^power_analysis_framework_2-13]\n\n[^power_analysis_framework_2-13]: These may be generated by draws based on a canonical distribution, like the Gaussian ('normal') with particular parameters. Alternately, if prior 'similar' data is available (e.g., from outcomes in the year prior to a field experiment), we may prefer to generate it by resampling from this.\n\nWe generate data sets generated to be *specific* to the study's goal. E.g., suppose we want to know the 'power to detect an effect size of 0.2 SD'.[^power_analysis_framework_2-14] Here, for considering the true positive and false negative rates, we should generate data that reflects this effect size. If we also want to measure the rate of type-2 error[^power_analysis_framework_2-15] we should also generate data reflecting a 'null effect'.\n\n[^power_analysis_framework_2-14]: I.e., the power of a particular design and testing procedure...\n\n[^power_analysis_framework_2-15]: I.e., the rate of false positives, i.e., if the null, e.g., an effect side of 0, holds.\n\n2.  **Run the proposed analysis over the many simulated data sets.** (Do this as efficiently as possible, as it can take a long time.) This analysis should either return the estimand of interest, or ensure that we can easily compute it (in Step 3). The output should be kept as flexible as possible (while conserving computer memory). This will allow us to assess multiple inference goals on the same output.[^power_analysis_framework_2-16]\n\n3.  **Summarize the output** returned in Step 2. **Compute the share** **of simulated data sets that meet particular** **inference goals** or decision criteria. (Example described in fold)\n\n[^power_analysis_framework_2-16]: E.g., in a Bayesian analysis, we can generate the full posterior distribution for an analysis. This can then be assessed and summarised in many ways in step 3.\n\n::: {.callout-note collapse=\"true\"}\n## Example: a simple case of simulating data to measure power\n\nE.g., we might simulate 1000 data sets based on an effect size of 0.3 standard deviations and perform a standard t-test of the difference between treatment and control for each of these. We might then find that for 743 of 1000 of these simulated data, the test 'rejected the null hypothesis', suggesting a power of 74.3%.\n\n<!-- Feel free to add other examples here. -->\n:::\n\nThis can show the likelihood of achieving a range of goals (under various sample sizes and design and testing choices) including the rates of *misleading* conclusions. In frequentist analyses, steps 2 and 3 can often be done together (e.g., the p-value is returned along with the other output). In my experience with typical Bayesian designs, these stages are best kept separate so that we can first do the more time-consuming Step 2, and then more freely explore the various options in Step 3.\n\n4.  **Assess the output** and determine whether the proposed analyses and inference goals are realistic and likely to yield informative results. If not, consider alternative design or data-collection choices (including sample sizes, treatments, and treatment assignments) or inference goals, and return to Step 1.[^power_analysis_framework_2-17]\n\n[^power_analysis_framework_2-17]: We don't refer to this as 'new ways of generating data' because... It seems wrong to first say, e.g., 'we assumed the a standard normal distribution of outcomes with a standard deviation equal to that observed in prior trials'... and then say 'but that didn't have enough power so let's assume a more concentrated distribution'. What we mean is to consider other ways of actually *collecting* data or setting up the experiment that would lead to a reasonable expectation of a different data generating process, and then simulate and diagnose this *new* approach. Note that DD seems to have good tools for comparing and considering design variations. Of course, there might also be a time to 'know when to fold-em'.\n\nIn the following sections, we present some generally useful packages and functions for power analyses. We give annotated code examples, highlighting useful aspects. We do this in the context of a frequentist power analysis for between-groups analysis.[^power_analysis_framework_2-18]\n\n[^power_analysis_framework_2-18]: We give this example is primarily because between-groups (aka 'between-subject') analyses run much more quickly than within- subjects analyses. Thus, these can be run without a time wasting headache on your own computer! We hope to add (and link or connect) further examples of common designs in future.\n\n[^power_analysis_framework_2-19]\n\n[^power_analysis_framework_2-19]: Willem has some nice procedures for generating repeated-measures data in [his walkthrough](https://willemsleegers.com/content/posts/9-simulation-based-power-analyses/simulation-based-power-analyses.html), see also his ['power curves'](https://willemsleegers.com/content/posts/10-simulation-based-power-curves/simulation-based-power-curves.html) using the library MASS.\n\n### Possible pitfalls/misunderstandings of power analysis\n\nPower analyses are a useful tool for considering the basic plausibility of achieving certain goals. But they are not an 'omniscient oracle', and may be somewhat of a blunt instrument. They might better be termed 'power projections' or 'power estimates'. Even if we *estimate* that we have 99.9% power for detecting some a particular effect, we may have specified our simulations in an unrealistic way. When we actually run an experiment, we might see (e.g.) far more underlying variation or measurement error than we predicted, leading our analyses to be fairly uninformative. Conversely, we might be overly conservative with our power analysis; perhaps a design we thought was 'underpowered' actually has a high probability of producing very compelling results.\n\n*Considering: when can power analyses be helpful? and when can they be limited*\n\n::: {.callout-note collapse=\"true\"}\n## Intricate data exploration versus broad inference\n\nWhen we see real data and real interesting patterns emerge, we are likely to go further in modeling and investigating these patterns than some of the more simple analyses and comparisons we conduct in the initial power analysis. I suspect power analyses are not so good for determining all the intricate, in-depth things we might plumb in a dataset. They are probably better at assessing the tractability of a broad inference goal.\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Complex models, forking paths, and tractibility\n\nWe might want to give some consideration to how far we wish to go in the initial data simulation step to think about all sorts of hypothetical data sets. As models become more complex, the number of different parameters that might vary - with possible effects on power - starts to balloon. E.g., even in a simple repeated-measures example, do we wish to vary not only the effect size but all sorts of different correlations from pre- to post-treatment within subjects? If we are simulating ordinal data, then power might change depending on how we initially suggest binning the outcomes, but there are infinitely many ways we might think the data might look... Discussion and consideration of how far we should go with these things is welcome and could be useful! (DR: I'm not sure what you are getting at here. Are you saying that 'the space of designs and proposed analyses we can explore is extremely large, and we may need to make some ad-hoc choices to avoid this getting unmanageable'?)\n:::\n\n## Concrete implementation of framework\n\n### Step 1: Generate a large number of data sets for the analysis\n\n#### Confirm that we can generate the basic data we want {.unnumbered}\n\nIn many simulations we end up generating some rather large data files: thus, we first increase the memory limit allotted to R.[^power_analysis_framework_2-20]\n\n[^power_analysis_framework_2-20]: I don't believe there is any real cost to increasing this memory limit, so it is wise to do so as to avoid a function iterating many times over for a long time, but ending up without sufficient space to store the outcome. DR: There must be some cost, otherwise why wouldn't it be a default? I guess it depends on the system/hardware.\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n:::\n\nNow we want to generate a hypothetical data set. In this case, we will be comparing four groups, each shown a different message in a between-subjects design (three active groups vs. a control condition with a neutral message).\n\nIn this example, the 'different groups' in our design play a second role in helping us assess our power against several different possible effect sizes.[^power_analysis_framework_2-21] <!-- DR: put in footnote because it seemed obvious to me. -->\n\n[^power_analysis_framework_2-21]: We can put these into a multiple regression and assess whether these different effect sizes 'come out as significantly different from our control group'. Thus we can diagnose our power to detect different sizes of effects.\n\n::: {.cell}\n\n```{.r .cell-code}\n# tidyverse simply used for data wrangling and plotting\nlibrary(tidyverse)\n```\n:::\n\nCode: The `four.group.datamaker` function creates a tibble (data frame) of\n\n-   a (std) normally distributed outcome\n-   an ordinal categorization of this outcome\n-   with four groups, each with (potentially) different outcome means\n-   with `ppg` rows per group\n-   with defaults as described\n\n::: {.cell}\n\n```{.r .cell-code}\nfour.group.datamaker <- function(sim = 1, a = 0, b = .1, c = .2, d = .4, ppg=1500) {\n\n#DR I renamed it `ppg` for 'population per group' because `pop` confused me\n\n  # first a tibble (data frame) with 1500 ppts, with the different groups showing\n  # effect sizes in Cohen's d of .1, .2, and .4\n  four.groups <- tibble(a.control = rnorm(ppg, a, 1),\n                        b.small = rnorm(ppg, b, 1),\n                        c.medsmall = rnorm(ppg, c, 1),\n                        d.medium = rnorm(ppg, d, 1),\n                        counter = 1:ppg) %>% #we previously called the counter 'sample.size' because of its later use\n\n    # turn the data into long form\n    pivot_longer(cols = 'a.control':'d.medium', names_to = 'group', values_to = 'response') %>%\n\n    # put cutpoints in the data to make it more similar to the ordinal responses we would get\n    mutate(ordinal = case_when(response < -1.5 ~ 1,\n                               response < -.5 ~ 2,\n                               response < .5 ~ 3,\n                               response < 1.5 ~ 4,\n                               response >= 1.5 ~ 5),\n\n           # for the purposes of this demo we will not analyse it as ordinal as it takes longer\n           # to run the regressions, but if you did so you would also want to make the response\n           # a factor\n           ordinal = as.factor(ordinal),\n           sim = sim)\n\n  return(four.groups)\n\n }\n```\n:::\n\nWe plot the data generated in one instance, to check our code and setup:\n\n::: {.cell}\n\n```{.r .cell-code}\n# test that the function works to make one data set before making many!\ntest.data <- four.group.datamaker()\n\nggplot(data = test.data) +\n  geom_density(aes(x = response, fill = group), alpha = .3) +\n  theme(\n    aspect.ratio = .5\n  ) +\n  ggtitle('Test four groups, continuous outcome')\n```\n\n::: {.cell-output-display}\n![](power_analysis_framework_2_files/figure-html/datamaker-test-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = test.data) +\n  geom_histogram(aes(x = as.numeric(ordinal)), alpha = .6,\n                 position = position_dodge(), bins = 10) +\n  facet_wrap(~group, nrow=1) +\n  theme(\n    aspect.ratio = 1\n  ) +\n  ggtitle('Test four groups, categorical outcome')\n```\n\n::: {.cell-output-display}\n![](power_analysis_framework_2_files/figure-html/datamaker-test-2.png){width=672}\n:::\n:::\n\nWe can see from the plots that the function appears to be working. When developing a data set for the first time, one would usually go further with some 'diagnostic' checks to confirm that the data is behaving as you intended.[^power_analysis_framework_2-22]\n\n[^power_analysis_framework_2-22]: For example, in Willem's examples, he used the `mvnorm` function with `'empirical = TRUE'` to inspect the data being generated with the exact mean-differences specified. This can then be confirmed with descriptive statistics. You are testing whether your 'parameters make sense'. Naturally, you turn off `empirical = TRUE` when actually *running*.\n\n#### Efficiently generate many data sets {.unnumbered}\n\nNow we just need to run the function above many times over. This could be done using loops, but a very useful set of R functions in the tidyverse is the `purrr` package of *map functions*. Even better, a package called `furrr` is available to run such map functions in parallel to further reduce time.[^power_analysis_framework_2-23] For `furrr` to do this, we need to tell it to plan for 'multisession', and give it a seed in the code below. [^power_analysis_framework_2-24]\n\n[^power_analysis_framework_2-23]: This doesn't matter so much here because this will be quite quick anyway, but is important when we run the analyses over the many data sets.\n\n[^power_analysis_framework_2-24]: DR: I don't think we *need* to give it a seed, but it's a good practice\n\n::: {.cell}\n\n```{.r .cell-code}\np_load(furrr)\nlibrary(furrr)\n\nplan(multisession)\noptions <- furrr_options(seed = 48238)\n```\n:::\n\nCode: We map over all 500 elements of the vector `nsims` to create 500 simulated data sets.[^power_analysis_framework_2-25]\n\n[^power_analysis_framework_2-25]: `future_map_dfr` works just like `map_dfr`, but enabling parallelization. It 'returns a data frame generated by row-binding.' (DR: this took about 4 seconds to run on my M1 Mac.) If we used `future_map` instead, it would give us a list of 500 tibbles. But then we break it back up again into that list, I'm not sure why.\n\n::: {.cell}\n\n```{.r .cell-code}\n# we will pass N = 500 simulations to the map function\nnsims <- 1:500\n\n# the map function will run our data-making function over nsims=500 simulations\nsim.data <- furrr::future_map_dfr(\n  .x = nsims,\n  .f = four.group.datamaker,\n  a = 0,\n  b = .1,\n  c = .2,\n  d = .4,\n  .options = options\n)\n\n# split the simulated data into the separate simulations\n\nsim.data <- sim.data %>% group_by(sim) %>% group_split()\n```\n:::\n\nNow, we have 500 simulated data sets representing our hypothetical outcome data, and can perform analyses on them. Here's a peek at part of one of these data sets, the third simulation:\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(sim.data[[3]])\n```\n\n::: {.cell-output-display}\npreserved5d2187b02cabb1f\n:::\n:::\n\n### Step 2: Run the proposed analysis over the many data sets and return the estimands of interest\n\nBefore we run an analysis over the many simulated data sets, we should to check that our models can run on these, and that they will return the estimands we are looking for. For a Bayesian analysis, this step might involve dropping parts of the posterior that are not relevant[^power_analysis_framework_2-26] and ensuring we get the parts we care about (e.g., we might insert additional code to retrieve a posterior distribution for Cohen's d).[^power_analysis_framework_2-27]\n\n[^power_analysis_framework_2-26]: e.g., estimates of every participant intercept, which take too much space for what they are worth\n\n[^power_analysis_framework_2-27]: ...Or simply the parameter estimate for the interaction. (DR: what interaction?) For Bayesian analyses I err on the side of getting as many of the main parameters as possible, because this is a very time-consuming step.\n\nFor frequentist analyses, there are also a range of estimands we might care about, depending on our estimation and inference goals. For example, we might consider returning a p-value, or the upper and lower bounds for confidence intervals, or r-squared estimates, etc.\n\nThe key point: before you drop the large set of simulated data sets and the regression results for each, make sure you every estimated that might be of interest; you don't want to have to to re-run the entire analysis.\n\nIn addition, you want to run the analysis on different sample sizes of the data, to generate a *power curve plot*. I.e., a plot showing how your power increases as you increase the sample size.\n\nIn the example function below, we run a simple linear regression, predicting the response from group.\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear.reg.maker <- function(data, breaks) { #runs a particular regression over a set of cuts of larger and larger subsets of  multiple data sets\n\n  # this function cuts the data set it is given into different sample sizes\n  cut.samples <- function(break.point, data) {\n    cut.data <- filter(data, counter <= break.point) %>%\n      mutate(sample.size = break.point)\n    return(cut.data)\n  }\n\n  data.cuts <- map_dfr(.x = breaks, .f = cut.samples, data = data)\n\n  # the data is split according to the sample size\n  # to feed to the regression model\n  data.cuts <- data.cuts %>% group_by(sample.size) %>% group_split()\n\n  # this function runs the regression\n  run.reg <- function(data) {\n\n    four.group.form <- as.numeric(ordinal) ~ 1 + group\n\n    four.group.reg <-\n      lm(formula = four.group.form,\n           data = data)\n\n    # we extract confidence intervals for the parameters of interest\n    ci99 <- confint(four.group.reg, level = .99)\n    ci95 <- confint(four.group.reg, level = .95)\n\n    # we create an 'output' to show the confidence intervals around the effects\n    # and some additional inference info, e.g., 'nonzero' indicates whether\n    # the lower bound of the CI excludes 0 or not.\n    # 'width' indicates the width of the confidence interval,\n    # for assessment of precision\n    output <- tibble(group = c('small', 'medsmall', 'medium',\n                               'small', 'medsmall', 'medium'),\n                     interval = c(.99, .99, .99, .95, .95, .95),\n                     lower = c(ci99[[2,1]], ci99[[3,1]], ci99[[4,1]],\n                               ci95[[2,1]], ci95[[3,1]], ci95[[4,1]]),\n                     upper = c(ci99[[2,2]], ci99[[3,2]], ci99[[4,2]],\n                               ci95[[2,2]], ci95[[3,2]], ci95[[4,2]])) %>%\n  #DR: maybe this code should be made a little more flexible?; because if you wanted to consider additional-sized effects you would need to expand the entries above\n\n      mutate('nonzero' = case_when(lower > 0 ~ 1,\n                                   TRUE ~ 0),\n             'width' = abs(upper - lower),\n             'sim' = data[[1, 'sim']],\n             'cell.size' = nrow(data)/4)\n\n    return(output)\n  }\n\n  # run the regression function over the different sample sizes\n  output <- map_df(.x = data.cuts, .f = run.reg)\n\n  return(output)\n}\n```\n:::\n\n<!-- Todo: show our testing of the function above? -->\n\nOnce we have made and tested that our function works as intended and returns the values we want to make inferences from, we can run it over the many simulated data sets:\n\n::: {.cell}\n\n```{.r .cell-code}\nt1 <- Sys.time()\nlinreg.output <- future_map_dfr(.x = sim.data,\n                                .f = linear.reg.maker,\n                                breaks = seq(from = 150, to = 1500, by = 150))\nt2 <- Sys.time()\nt2 - t1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 19.54922 secs\n```\n:::\n:::\n\nThe object `linreg.output` is now a large dataframe, cataloguing whether or not certain inference thresholds were reached across the many simulations. In the third primary step, we can summarise and graphically display this information.\n\n### Step 3: Summarise the output returned in Step 2 to determine the likelihood of achieving various inferential goals\n\nNow, we want to know how likely we are to achieve a range of inferential goals, depending on factors such as the sample size, the underlying effect sizes, or anything else we varied in simulating our data and running our models. For this example, this is as simple as generating a summary of the output from Step 2... ^[The code below groups the results by group (effect size), confidence interval, and sample size, summarizes the 'share of CI's that don't overlap zero, and cleans things a bit.]\n\n::: {.cell}\n\n```{.r .cell-code}\n# group the data according to group, confidence interval, and size per group\nfour.group.lin.summary <- linreg.output %>% group_by(group, interval, cell.size) %>%\n  # summarise the amount of times we get a CI greater than 0\n  summarise(.groups = 'keep',\n            'ci above 0 vs. control' = sum(nonzero)/5)  %>%\n  # change some factors for plotting\n  mutate(interval = factor(interval, levels = c('0.95', '0.99'),\n                           labels = c('95% CI', '99% CI')),\n         'Effect size' = factor(group, levels = c('small', 'medsmall', 'medium'),\n                                labels = c('Very small (.1)', 'Small (.2)', 'Medium (.4)')))\n```\n:::\n\nA... and then plotting the resulting power curve:\n\n::: {.cell}\n\n```{.r .cell-code}\n(\npower_curve_4_group_lin <- ggplot(data = four.group.lin.summary) +\n  scale_x_continuous(limits = c(100, 1550), breaks = seq(from = 150, to = 1500, by = 150)) +\n  scale_y_continuous(limits = c(0, 100), breaks = seq(from = 0, to = 100, by = 20)) +\n  geom_hline(aes(yintercept = 80), linetype = 'dashed', size = .33, alpha = .25) +\n  geom_hline(aes(yintercept = 90), linetype = 'dashed', size = .33, alpha = .25) +\n  geom_path(aes(x = cell.size, y = `ci above 0 vs. control`, color = `Effect size`,\n                group = `Effect size`), size = .66) +\n  geom_point(aes(x = cell.size, y = `ci above 0 vs. control`, color = `Effect size`),\n             size = 1.5) +\n  labs(y = 'Power to detect a non-zero effect',\n       x = 'Number of participants per condition (control group not included)') +\n  scale_color_manual(values = c('#c10d0d', '#7dc3c2', '#dcc55b')) +\n  facet_wrap(~interval) +\n  theme(\n    aspect.ratio = 1,\n    panel.grid.major = element_line(colour = \"white\", size = 0.33),\n    panel.grid.minor = element_line(colour = \"white\", size = 0.2),\n    panel.background = element_rect(fill = \"grey96\"),\n    axis.line = element_line(color = 'black', size = 0.375),\n    axis.ticks = element_line(color = 'black', size = 0.5),\n    text = element_text(color = 'black', family = 'Gill Sans MT', size = 9),\n    axis.text = element_text(color = 'black', family = 'Gill Sans MT', size = 7),\n    strip.background = element_blank()\n  )\n)\n```\n\n::: {.cell-output-display}\n![](power_analysis_framework_2_files/figure-html/plot-power-curve-1.png){width=672}\n:::\n:::\n\n### Step 4. Assess the output and determine whether the proposed analyses and inference goals are realistic and likely to yield informative results.\n\nIn Step 4, we use the information we have generated above to make substantive conclusions about the projected power of our experiment to detect particular effects, given particular underlying parameters. From this we can make recommendations as to experimental design.\n\nBased on the power curve plotted above, we can conclude that we would have a very high likelihood of detecting effects of .4 versus a control group at even quite low sample sizes, and also a good possibility of detecting effect sizes of .2 at quite modest sample sizes. On the other hand, for the very small effect size, we would not be likely to detect a difference from a control group even with 1500 participants per group. If effect sizes of this sizes are of interest, then we might consider going back to Step 1 and reconsidering our experimental design to include more participants.",
    "supporting": [
      "power_analysis_framework_2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {
      "preserved5d2187b02cabb1f": "<table class=\"huxtable\" style=\"border-collapse: collapse; border: 0px; margin-bottom: 2em; margin-top: 2em; ; margin-left: auto; margin-right: auto;  \" id=\"tab:check-data\">\n<col><col><col><col><col><tr>\n<th style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0.4pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; font-weight: bold;\">counter</th><th style=\"vertical-align: top; text-align: left; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: bold;\">group</th><th style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: bold;\">response</th><th style=\"vertical-align: top; text-align: left; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: bold;\">ordinal</th><th style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0.4pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: bold;\">sim</th></tr>\n<tr>\n<td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">1</td><td style=\"vertical-align: top; text-align: left; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">a.control</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">-0.395&nbsp;</td><td style=\"vertical-align: top; text-align: left; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">3</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0.4pt 0.4pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">3</td></tr>\n<tr>\n<td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">1</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">b.small</td><td style=\"vertical-align: top; text-align: right; white-space: normal; padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">-0.396&nbsp;</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">3</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0.4pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">3</td></tr>\n<tr>\n<td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">1</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">c.medsmall</td><td style=\"vertical-align: top; text-align: right; white-space: normal; padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">-0.0762</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">3</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0.4pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">3</td></tr>\n<tr>\n<td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">1</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">d.medium</td><td style=\"vertical-align: top; text-align: right; white-space: normal; padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">0.994&nbsp;</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">4</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0.4pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">3</td></tr>\n<tr>\n<td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">2</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">a.control</td><td style=\"vertical-align: top; text-align: right; white-space: normal; padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">-0.931&nbsp;</td><td style=\"vertical-align: top; text-align: left; white-space: normal; padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">2</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0.4pt 0pt 0pt;    padding: 6pt 6pt 6pt 6pt; background-color: rgb(242, 242, 242); font-weight: normal;\">3</td></tr>\n<tr>\n<td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0.4pt 0.4pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">2</td><td style=\"vertical-align: top; text-align: left; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">b.small</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">-1.58&nbsp;&nbsp;</td><td style=\"vertical-align: top; text-align: left; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">1</td><td style=\"vertical-align: top; text-align: right; white-space: normal; border-style: solid solid solid solid; border-width: 0pt 0.4pt 0.4pt 0pt;    padding: 6pt 6pt 6pt 6pt; font-weight: normal;\">3</td></tr>\n</table>\n"
    },
    "postProcess": true
  }
}